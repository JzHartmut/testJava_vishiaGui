= A test script generator StimuliSelector
:toc:
:sectnums:
:sectlinks:
:cpp: C++
:Cp: C/++

Dr. Hartmut Schorrig, www.vishia.org, 2020-11-13

== Motivation

Often tests are controlled by scripts, or the test environment (test bench) is any source containing the test conditions. For different tests more as one scripts are necessary which should be select to use.

But the scripts are equal in wide range, only specific parts are adapted to different test cases. Hence it is better to generate the yet necessary test script from a template with place holder and replace the place holder with the correct values.

The link:JZtxtcmd.html[] is used to generate the scripts. A GUI environment build with the vishia Gral concept is used for selection of parameter of generation.

This concept is flexible to use for all approaches where scripts should be generated to control tests or also parameter etc. The adaption is based on script files.

== Principle: Text template with placeholder

Supposed, a script is necessary to control the test. This script may be:

* A main program or function in a source which is a test bench for a module in {Cp} language.
* A header file which contains some compiler switch definitions.
* For Simulink: A math script or text file with parameter
* FPGA-simulation: A VHDL file which is the test bench
* A XML file or yaml file which contains parameter of test 
* A flow written in Phyton which controls a test
* ... somewhat else, a textual script

For a simple explanation a simple test file with parameters and a XML file is presented here:

----
#Simple test script with parameter
title = "t1_v1"
value1 = 123.45
value2 = "text"
----

Adequates in XML:
----
<?xml version="1.0" encoding="ISO-8859-1"?>
<Test:root xmlns:Test="https://myUrl/TestDefs" Test:title="t1_v1">
  <Test:Values Test:value1="123.45" Test:value2="text" />
</Test:root>
----

The content of this files are an example, it is user specific. 

You need a file which contains exactly this texts but with place holder for the values. 
The place holder are written in the form: `<&path.variable>`. But additionally a frame for the text is necessary. So the template for the text file for this example is  (file `testfile_text.jzTc`):  

----
==JZtxtcmd==

##
##Template for the whole testfile_text.
##arguments values and texts comes from the selected lines of the Test stimuli
##
subtext testfile_text(String title, Map values, Map texts) 
<::>
#Simple test script with parameter
title = "<&title>"
value1 = <&values.value1>
value2 = "<&texts.text>"
<.>  ## 
----

The area between `<::>` and the closing `<.>` is the whole original text with the placeholder. The text is organized in JZtxtcmd as 'subtext' syntax, with calling arguments, see link:JZtxtcmd.html#Topic.JZtxtcmd.script.sub.[]. The template script can also contain comments written as `pass:[##line end comment]` which are not part of the generated result. A simple `#` is not a comment because often the `#` is need to generate comment lines. Of courses that requirement or feature is regarded in JZtxtcmd.

It is also possible in XML (file `testfile_xml.jzTc`):
----
==JZtxtcmd==

##
##Template for the whole testfile_xml.
##arguments values and texts comes from the selected lines of the Test stimuli
##
subtext testfile_xml(String title, Map values, Map texts) 
<::>
<?xml version="1.0" encoding="ISO-8859-1"?>
<Test:root xmlns:Test="https://myUrl/TestDefs" Test:title="<&title>">
  <Test:Values Test:value1="<&values.value1>" Test:value2="<&texts.text>" />
</Test:root>
<.> ##
----

JZtxtcmd is proper also and especially for generation of results which uses elaborately writing with `< ... >` for example XML, but also some other script languages e.g. the Mathworks-specific "tlc" scripts ("__target language compiler__" control script). The distinction to XML style is: The placeholder start with `<&` which is never used in XML as necessary direct text. Some control constructs start with `<:` also not used in XML. But nevertheless this character sequences can be written as `<:<&>` etc. see link:JZtxtcmd.html#Topic:.JZtxtcmd.text.transcript.[].

== Tables with the values for placeholder, test variants

From where come the values?

You should define tables, file  (file `stimuliTables.jzTc` in the appended example):

----
==JZtxtcmd==

List values @name =  
[ { name="v1", descr="test-var 1", value1="123.45", value2="536.5" }
, { name="v2", descr="test-var 2", value1="345.67", value2="5" }
, { name="v3", descr="test-var 3", value1="987.65", value2="1000" }
];

List texts @name =
[ { name="t1", descr="text1", text="text" }
, { name="t2", descr="text2", text="other text" }
];
----

One line of this tables is a `java.util.Map` container. The key is that variable which is designated after the `@` in the list's head. It is organized as JZtxtcmd script. The line should contain a variable named `descr` for the GUI tool, and can contain any desired variable furthermore, but each line the same ones.

The tables build groups of selectable test cases, which can be used for manual selection, and also for test generation. 

== The GUI for test case selection

This GUI is a Java program using Eclips-swt as graphic driver. It is invoked with (file `stimuli.jzT.cmd`):

----
REM starts as windows command (batch) file:

set LIBSPATH="../../../.."
set CP="%LIBSPATH%/libs/vishiaGui.jar;%LIBSPATH%/libs/vishiaBase.jar;%LIBSPATH%/libs/org.eclipse.swt.win32.win32.x86_64.jar"                                                    
set JAVAW=java
::cd ..\..\..\..
echo dir=%CD%
REM call the GUI. This file %0 is used as argument for SimSelector. It contains all control after the JZtxtcmd label
echo on 
%JAVAW% -cp %CP% org.vishia.simSelector.SimSelector %0 -size:C       
echo off
pause
exit /b
----

The class creating the GUI is the `org.vishia.simSelector.SimSelector`. The argument is this file itself (`%0` as full path here), used as JZtxtcmd script for organization of the GUI.

The GUI with this given tables looks like:

image:../img/TestStimulator/TestStimulator_1.png[]

The same example file `stimuli.jzT.cmd` contains also the generation sub routine, the routine for the [gen selection] button and the association to the tables:

----
==JZtxtcmd==

currdir=<:><&scriptdir><.>;

include stimuliTables.jzTc;
include testfile_text.jzTc;
include testfile_xml.jzTc;
----

Above it is the start of the JZtxtcmd script. With the designation `==JZtxtcmd==` on start of a line it is marked as JZtxtcmd script inside this `*.cmd` file. The `exit /b` as last statement above ends the usage as cmd. The other files are included here. 

----
sub btnGenSelection ( Map line1, Map line2, Map line3, Map line4, Map line5, Map line6) {
  <+out><&scriptdir>/<&scriptfile>: btnGenSelection ( 
     <&line1.name>, <&line2.name>) ..... <.+n>; 
  call genTestfiles(values=line1, texts=line2);
}
----

This is the JZtxtcmd sub routine which is searched and used by the GUI. The arguments are the selected lines in the possible 6 tables. The sub routine calls the generation routine, only the arguments of the common defined button routine are associated to the application specific names of the generation routine.


----
sub genTestfiles(Map values, Map texts) {

  String title = <:><&texts.name>_<&values.name><.>;     ## build the title
  mkdir genScripts;
  Openfile fText = "genScripts/testfile_text.txt";
  <+fText><:call:testfile_text : title=title, values=values, texts=texts><.+>
  fText.close();
  Openfile fXml = "genScripts/testfile_xml.xml";
  <+fXml><:call:testfile_xml : title=title, values=values, texts=texts><.+>
  fXml.close();
}
----

This is the generation routine. The two expected files (example) are generated via calling the subtext which contains the template text with place holder. That's all for this example.

----
class ToGui 
{
  List tdata1 = values;
  List tdata2 = texts;
}
----

Last not least the GUI should know which tables should be used to show and select. A so named `class` in JZtxtcmd is used to associate the tables. The GUI java program searches this class and the `tdata..` variables. Here only 2 tables are used. 

With 6 tables test cases with 6 coordinates to modify tests (builds combinations) are possible. The GUI can be enhanced for example to use 12 coordinates or combination variants, using 4 x 3 tables, obviously on a normal monitor, or more. But in practical usage 6 coordinates seems to be enough. 

== Manual selected and automatic tests

Firstly this GUI and the tables support manual selected test cases in several combinations. This example is held simple, but some combinations should be imaginable also for this example.

With 6 combinations of for example 10 entries per table a lot of combinations are possible (10^6 = 1000000, only for example).

It means, before establish automatic test cases reasonable combinations should be found. Manual tests with expertise of the results can help to find the combinations. 

To explain this on a common example, the test cases are extended. 

image:../img/TestStimulator/TestStimulator_5Tables.png[]

You see, five of six tables are filled, with few modifications only. 

=== Test case selection

The idea is: Assembling some test cases on demand and study manually the behavior. It is possible to write a pattern to select some test cases. They can be executed automatically one after another. This is the preparation of the next chapter: Execute nightly tests with the stimuli

If you know your system, know which test cases are proper for test all features, not all combinations should be test, but specific significant combinations, not too much for a fast or a nightly test.

Now you can select combinations. The image above shows a text box with a selection of test cases. This uses the key values (in the left column of each table) to select the cases in combination. The syntax for it is:

----
select::= { <selAnd> ? : }.    <.>
selAnd::= { <selAdd> ? & }.    <.>
selAdd::=  { <selLines> ? + }. <.>
selLines::= { <#table> = {<$?selItem> ? , } [;] }. <.>
----

The syntax is written as link:../../docuZBNF/sfZbnfMain_en.html[ZBNF] expression.

* 4) Should come to know from inner to outer. You see this expression in the image:

 1=v1,v2; 2=t1, t2;
 
* It means that the table line with key `v1` and `v2` from table 1 are selected to test, in combination with `t1` and `t2` from the table 2. 

* 3) It is possible to have more independent combinations, separated with ,,+,, - means add selection combination. In the image you see a second combination which should use to test:

 + 1=v2, v3; 2=t1, t2; 
 
* 2) The ,,&,, means '__and with__'. It is a selection with other tables which are combined with the given combinations. Of course you may have here also more combinations separated with ,,+,,. The example 

 & 3=A1, A2; 4=B1, B2; 5=C1, C2
 
* does only show one combination of the other table. 

* 1) Not demonstrate in the image and for the [exmpl] button: You can have more independent combinations with the tables. All are added. 

With the shown select expression the following combinations are tested:


How to get this select expression?

* You can write it manually in knowledge of the keys in the lines of tables.

* You can select a line, double click to get the entry, the write the separator characters manually. It is more simple.

* You can select more as one line in a table using the 'arrow down' key while 'shift' is pressed. It marks a line. Mark some lines, think about, then press the [add sel] botton. To deselect the marked lines you can press the [desel] button. It is more simple than manually deselect. Repeat it for the next table. 

* If you press [exmpl] then you get an example using the given table content, which shows you the syntax. Based on this example you can modify it. 


=== Test case generation

The button [gen test cases] calls the sub routine 